import fs from "fs";
import path from "path";
import kleur from "kleur";
import { diffLines } from "diff";
import { exec } from "child_process";

interface AliasMatch {
  modelName: string;
}

export interface PrismifyConfig {
  schemaFolderPath: string;
  outputFilePath: string;
  watchMode: boolean;
  logDiffs: boolean;
}

export class Prismify {
  private config: PrismifyConfig;
  private previousSchemaContent: string;

  public constructor(config: PrismifyConfig) {
    this.config = config;
    this.previousSchemaContent = "";
  }

  private formatElapsedTime(startTime: number, endTime: number): string {
    const elapsedTime = endTime - startTime;
    return `${elapsedTime} ms`;
  }

  private searchForSchemaFiles(dir: string): string[] {
    const schemaFiles: string[] = [];
    const files = fs.readdirSync(dir, { withFileTypes: true });

    files.forEach((file) => {
      const filePath = path.join(dir, file.name);

      if (file.isDirectory()) {
        schemaFiles.push(...this.searchForSchemaFiles(filePath));
      } else if (file.isFile() && file.name.endsWith(".prisma")) {
        schemaFiles.push(filePath);
      }
    });

    return schemaFiles;
  }

  private generateUnifiedSchema(): string {
    const schemaFiles = this.searchForSchemaFiles(this.config.schemaFolderPath);

    const baseSchemaPath = path.join(
      this.config.schemaFolderPath,
      "Base.prisma".toLowerCase()
    );
    if (!fs.existsSync(baseSchemaPath)) {
      console.error(kleur.red("âŒ Required file 'Base.prisma' not found."));
      process.exit(1);
    }

    const baseSchema = fs.readFileSync(baseSchemaPath, "utf-8");
    const schemaContents = schemaFiles
      .map((filePath) => {
        const aliasRegex = /\/\/Alias([\s\S]*?)\}/g;
        const content = fs.readFileSync(filePath, "utf-8");
        const contentWithoutAlias = content.replace(aliasRegex, "");
        return filePath === baseSchemaPath ? "" : contentWithoutAlias;
      })
      .join("\n");

    const warningComment =
      "// WARNING: This file is generated by Prismify. Do not edit this file.";
    const generatedSchema = `${warningComment}\n\n${baseSchema}\n\n${schemaContents}`;

    return generatedSchema;
  }

  private logSchemaGeneration(outputFilePath: string, elapsedTime: string): void {
    console.log(
      kleur.green().bold("âœ¨ Unified schema file generated:") +
        ` ${kleur.yellow(outputFilePath)} ${kleur.dim("(" + elapsedTime + ")")}`
    );
  }

  private appendAliasModelToSchema(file: string, modelName: string): void {
    const alias = `
  //Alias
  model ${modelName} {
    id     Int   @id @default(autoincrement())
  }`;

    fs.appendFileSync(file, alias);
    exec("npx prisma format --schema=" + file, {});
  }

  private checkForRelationsInSchema(file: string): AliasMatch[] {
    const content = fs.readFileSync(file, "utf-8");

    const regex = /\b(\w+)\[\]/gi;
    const matches: AliasMatch[] = [];
    let match: RegExpExecArray | null;

    while ((match = regex.exec(content))) {
      const modelName = match[1];
      matches.push({ modelName });
    }

    return matches;
  }

  private checkForRelations(): void {
    const schemaFiles = this.searchForSchemaFiles(this.config.schemaFolderPath);

    schemaFiles.forEach((file) => {
      const matches = this.checkForRelationsInSchema(file);

      matches.forEach((match) => {
        if (!fs.readFileSync(file, "utf-8").includes(`model ${match.modelName}`)) {
          this.appendAliasModelToSchema(file, match.modelName);
        }
      });
    });
  }

  private logSchemaDiffs(diff: any): void {
    const addedLines: string[] = [];
    const removedLines: string[] = [];

    diff.forEach((part: any) => {
      const { added, removed, value } = part;
      if (added) {
        addedLines.push(value);
      } else if (removed) {
        removedLines.push(value);
      }
    });

    if (addedLines.length > 0) {
      console.log(kleur.green().bold("\nðŸŸ¢ Changes Added:\n"));
      console.log(kleur.green(addedLines.join("")));
    }

    if (removedLines.length > 0) {
      console.log(kleur.red().bold("\nðŸ”´ Changes Removed:\n"));
      console.log(kleur.red(removedLines.join("")));
    }
  }

  private generateAndSaveSchema = (): void => {
    this.checkForRelations();
    const startTime = Date.now();
    const generatedSchema = this.generateUnifiedSchema();

    if (generatedSchema !== this.previousSchemaContent) {
      const diff = diffLines(this.previousSchemaContent, generatedSchema);

      fs.writeFileSync(this.config.outputFilePath, generatedSchema, "utf-8");
      this.previousSchemaContent = generatedSchema;

      const endTime = Date.now();
      const elapsedTime = this.formatElapsedTime(startTime, endTime);

      this.logSchemaGeneration(this.config.outputFilePath, elapsedTime);

      if (this.config.logDiffs) {
        this.logSchemaDiffs(diff);
      }
    }

    exec("npx prisma format --schema=" + this.config.outputFilePath, {});
  };

  public run(): void {
    this.generateAndSaveSchema();

    if (this.config.watchMode) {
      console.log(
        kleur.yellow().bold("ðŸ‘€ Watching for changes in:") +
          ` ${kleur.cyan(this.config.schemaFolderPath)}`
      );

      fs.watch(
        this.config.schemaFolderPath,
        { recursive: true },
        this.generateAndSaveSchema
      );
    }
  }
}
