import fs from "fs";
import path from "path";
import kleur from "kleur";
import { diffLines } from "diff";
import { exec } from "child_process";

export interface PrismifyConfig {
  schemaFolderPath: string;
  outputFilePath: string;
  watchMode: boolean;
  logDiffs: boolean;
}

export class Prismify {
  private config: PrismifyConfig;
  private previousSchemaContent: string;

  public constructor(config: PrismifyConfig) {
    this.config = config;
    this.previousSchemaContent = "";
  }

  private formatElapsedTime(startTime: number, endTime: number): string {
    const elapsedTime = endTime - startTime;
    return `${elapsedTime} ms`;
  }

  private searchForSchemaFiles(dir: string): string[] {
    const schemaFiles: string[] = [];
    const files = fs.readdirSync(dir);

    files.forEach((file) => {
      const filePath = path.join(dir, file);
      const isDirectory = fs.lstatSync(filePath).isDirectory();

      if (isDirectory) {
        schemaFiles.push(...this.searchForSchemaFiles(filePath));
      } else if (file.endsWith(".prisma")) {
        schemaFiles.push(filePath);
      }
    });

    return schemaFiles;
  }

  private generateUnifiedSchema(): string {
    const schemaFiles = this.searchForSchemaFiles(this.config.schemaFolderPath);

    const baseSchemaPath = path.join(
      this.config.schemaFolderPath,
      "Base.prisma".toLowerCase()
    );
    if (!fs.existsSync(baseSchemaPath)) {
      console.error(kleur.red("âŒ Required file 'Base.prisma' not found."));
      process.exit(1);
    }

    const baseSchema = fs.readFileSync(baseSchemaPath, "utf-8");
    const schemaContents = schemaFiles
      .map((filePath) => {
        const aliasRegex = /\/\/Alias([\s\S]*?)\}/g;
        const content = fs.readFileSync(filePath, "utf-8");
        const contentWithoutAlias = content.replace(aliasRegex, "");
        console.log(content.replace(aliasRegex, ""));
        return filePath === baseSchemaPath ? "" : contentWithoutAlias;
      })
      .join("\n");

    const warningComment =
      "// WARNING: This file is generated by Prismify. Do not edit this file.";
    const generatedSchema = `${warningComment}\n\n${baseSchema}\n\n${schemaContents}`;

    return generatedSchema;
  }

  private logSchemaGeneration(
    outputFilePath: string,
    elapsedTime: string
  ): void {
    console.log(
      kleur.green().bold("âœ¨ Unified schema file generated:") +
        ` ${kleur.yellow(outputFilePath)} ${kleur.dim("(" + elapsedTime + ")")}`
    );
  }

  private generateAndSaveSchema = () => {
    const startTime = new Date().getTime();
    const generatedSchema = this.generateUnifiedSchema();

    if (generatedSchema !== this.previousSchemaContent) {
      const diff = diffLines(this.previousSchemaContent, generatedSchema);

      fs.writeFileSync(this.config.outputFilePath, generatedSchema, "utf-8");
      this.previousSchemaContent = generatedSchema;

      const endTime = new Date().getTime();
      const elapsedTime = this.formatElapsedTime(startTime, endTime);

      this.logSchemaGeneration(this.config.outputFilePath, elapsedTime);

      if (this.config.logDiffs) {
        this.logSchemaDiffs(diff);
      }
    }

    this.checkForRelations();

    exec("npx prisma format --schema=" + this.config.outputFilePath, {});
  };

  private checkForRelations = () => {
    const schemaFiles = this.searchForSchemaFiles(this.config.schemaFolderPath);

    schemaFiles.forEach((file) => {
      const content = fs.readFileSync(file, "utf-8");

      const regex = /\b(\w+)\[\]/i;
      const match = content.match(regex);

      if (match) {
        if (!content.includes(`model ${match[1]}`)) {
          console.log(match);
          const alias = `
//Alias
model ${match[1]} {
id     Int   @id @default(autoincrement())
}`;

          fs.appendFileSync(file, alias);
          exec("npx prisma format --schema=" + file, {});
        }
      }
    });
  };

  private logSchemaDiffs(diff: any): void {
    const addedLines: string[] = [];
    const removedLines: string[] = [];

    diff.forEach((part: any) => {
      const { added, removed, value } = part;
      if (added) {
        addedLines.push(value);
      } else if (removed) {
        removedLines.push(value);
      }
    });

    if (addedLines.length > 0) {
      console.log(kleur.green().bold("\nðŸŸ¢ Changes Added:\n"));
      console.log(kleur.green(addedLines.join("")));
    }

    if (removedLines.length > 0) {
      console.log(kleur.red().bold("\nðŸ”´ Changes Removed:\n"));
      console.log(kleur.red(removedLines.join("")));
    }
  }

  public run(): void {
    this.generateAndSaveSchema();

    if (this.config.watchMode) {
      console.log(
        kleur.yellow().bold("ðŸ‘€ Watching for changes in:") +
          ` ${kleur.cyan(this.config.schemaFolderPath)}`
      );

      fs.watch(
        this.config.schemaFolderPath,
        { recursive: true },
        this.generateAndSaveSchema
      );
    }
  }
}
